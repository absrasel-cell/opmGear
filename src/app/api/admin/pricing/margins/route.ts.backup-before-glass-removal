import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { cookies } from 'next/headers';
import { createClient } from '@supabase/supabase-js';

interface TierMarginSetting {
  id: string;
  tierName: string;
  marginType: 'percentage' | 'flat';
  marginValue: number;
  isActive: boolean;
}

// Helper function to get current user
async function getCurrentUser(request: NextRequest) {
  try {
    const cookieStore = await cookies();
    const accessToken = cookieStore.get('sb-access-token')?.value;

    if (!accessToken) return null;

    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      {
        global: {
          headers: {
            Authorization: `Bearer ${accessToken}`,
          },
        },
      }
    );

    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) return null;
    
    // Get user data from database to check access role
    const userData = await prisma.user.findUnique({
      where: { id: user.id },
      select: {
        id: true,
        email: true,
        accessRole: true,
        adminLevel: true,
      },
    });
    
    return userData;
  } catch (error) {
    console.error('Authentication error:', error);
    return null;
  }
}

// Helper function to check admin access
function hasAdminAccess(user: any): boolean {
  if (!user) return false;
  return ['MASTER_ADMIN', 'SUPER_ADMIN', 'STAFF', 'ADMIN'].includes(user.accessRole);
}

// GET - Fetch all tier margin settings
export async function GET(request: NextRequest) {
  try {
    const user = await getCurrentUser(request);
    if (!hasAdminAccess(user)) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Get all active pricing tiers with their associated margin settings
    const pricingTiers = await prisma.pricingTier.findMany({
      where: { isActive: true },
      orderBy: { name: 'asc' }
    });

    // Get tier-specific margin settings from SimplifiedMarginSetting for BLANK_CAPS category
    // which we'll use as the base product margin setting
    const marginSettings = await prisma.simplifiedMarginSetting.findFirst({
      where: { 
        category: 'BLANK_CAPS',
        isActive: true 
      }
    });

    // Combine tiers with margin settings
    const tierMarginsData = pricingTiers.map(tier => ({
      id: tier.id,
      name: tier.name,
      factoryCosts: {
        price48: Number(tier.price48),
        price144: Number(tier.price144),
        price576: Number(tier.price576),
        price1152: Number(tier.price1152),
        price2880: Number(tier.price2880),
        price10000: Number(tier.price10000)
      },
      marginSettings: marginSettings ? {
        marginPercent: Number(marginSettings.marginPercent),
        flatMargin: Number(marginSettings.flatMargin),
        // Default to percentage if both exist and percent > 0
        activeType: Number(marginSettings.marginPercent) > 0 ? 'percentage' : 'flat'
      } : {
        marginPercent: 0,
        flatMargin: 0,
        activeType: 'percentage'
      },
      isDefault: tier.isDefault,
      isActive: tier.isActive
    }));

    return NextResponse.json(tierMarginsData);
  } catch (error) {
    console.error('Error fetching tier margin settings:', error);
    return NextResponse.json(
      { error: 'Failed to fetch tier margin settings' },
      { status: 500 }
    );
  }
}

// POST - Create or update tier margin settings
export async function POST(request: NextRequest) {
  try {
    const user = await getCurrentUser(request);
    if (!hasAdminAccess(user)) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await request.json();
    const { marginType, marginValue } = body;

    // Validate margin type and value
    if (!['percentage', 'flat'].includes(marginType)) {
      return NextResponse.json({ error: 'Invalid margin type' }, { status: 400 });
    }

    if (typeof marginValue !== 'number' || marginValue < 0) {
      return NextResponse.json({ error: 'Invalid margin value' }, { status: 400 });
    }

    // Update or create the BLANK_CAPS simplified margin setting which applies to base product pricing
    const marginData = {
      category: 'BLANK_CAPS' as const,
      marginPercent: marginType === 'percentage' ? marginValue : 0,
      flatMargin: marginType === 'flat' ? marginValue : 0,
      isActive: true,
      appliedScope: 'GLOBAL' as const,
      csvSourceInfo: 'Applied to base product pricing tiers',
      exampleItems: ['Base Cap Pricing', 'All Tier Pricing']
    };

    const existingSetting = await prisma.simplifiedMarginSetting.findFirst({
      where: { category: 'BLANK_CAPS' }
    });

    let marginSetting;
    if (existingSetting) {
      marginSetting = await prisma.simplifiedMarginSetting.update({
        where: { id: existingSetting.id },
        data: marginData
      });
    } else {
      marginSetting = await prisma.simplifiedMarginSetting.create({
        data: marginData
      });
    }

    // Clear pricing cache to ensure updated margins are reflected
    // This will be handled by the pricing.ts cache invalidation

    return NextResponse.json({
      success: true,
      marginSetting: {
        id: marginSetting.id,
        marginType,
        marginValue: Number(marginSetting.marginPercent > 0 ? marginSetting.marginPercent : marginSetting.flatMargin),
        activeType: marginSetting.marginPercent > 0 ? 'percentage' : 'flat'
      }
    });
  } catch (error) {
    console.error('Error updating tier margin settings:', error);
    return NextResponse.json(
      { error: 'Failed to update tier margin settings' },
      { status: 500 }
    );
  }
}

// PUT - Update specific tier margin (same as POST for this implementation)
export async function PUT(request: NextRequest) {
  return POST(request);
}