import { NextResponse } from 'next/server';
import { SanityService } from '../../../lib/sanity';

export async function GET() {
  try {
    console.log('üè≠ API: Fetching blank cap products...');
    
    // Test Sanity configuration
    const config = {
      projectId: process.env.NEXT_PUBLIC_SANITY_PROJECT_ID,
      dataset: process.env.NEXT_PUBLIC_SANITY_DATASET,
      apiToken: process.env.SANITY_API_TOKEN ? 'SET' : 'MISSING',
      environment: process.env.NODE_ENV
    };
    
    console.log('üè≠ API: Sanity config:', config);
    
    const sanityProducts = await SanityService.getProducts();
    console.log(`üè≠ API: Retrieved ${sanityProducts.length} total products from Sanity`);
    
    // Filter for blank cap products only (factory products that can be customized)
    const blankCapProducts = sanityProducts
      .filter((product: any) => {
        const isActiveProduct = product.isActive;
        const hasMainImage = product.mainImage?.url;
        const hasSlug = typeof product.slug === 'string' ? product.slug : product.slug?.current;
        const isFactoryProduct = product._type === 'product' || product.productType === 'factory';
        
        console.log(`üîç API: Product "${product.name}" - Active: ${isActiveProduct}, Image: ${!!hasMainImage}, Slug: ${!!hasSlug}, Type: ${product._type}, ProductType: ${product.productType}`);
        
        return isActiveProduct && hasMainImage && hasSlug && isFactoryProduct;
      })
      .map((product: any) => ({
        _id: product._id,
        name: product.name,
        slug: typeof product.slug === 'string' ? product.slug : product.slug?.current || '',
        mainImage: {
          url: product.mainImage.url,
          alt: product.mainImage.alt || product.name,
          name: product.name
        },
        description: product.description || '',
        priceTier: product.priceTier || 'Tier 1',
        _type: product._type,
        productType: product.productType || 'factory',
        billShape: product.billShape,
        profile: product.profile,
        closureType: product.closureType,
        structure: product.structure,
        isActive: product.isActive,
        basePrice: product.basePrice
      }))
      .filter(product => {
        const hasValidSlug = product.slug && product.slug.trim() !== '';
        if (!hasValidSlug) {
          console.warn(`‚ö†Ô∏è API: Product "${product.name}" has invalid slug, skipping`);
        }
        return hasValidSlug;
      })
      .slice(0, 8); // Limit to 8 products for the home page section

    console.log(`üè≠ API: Final blank cap products: ${blankCapProducts.length}`);
    
    return NextResponse.json({
      success: true,
      config,
      totalProducts: sanityProducts.length,
      blankCapProducts: blankCapProducts.length,
      products: blankCapProducts,
      debugInfo: {
        firstProduct: sanityProducts[0] || null,
        environment: process.env.NODE_ENV,
        timestamp: new Date().toISOString()
      }
    });
    
  } catch (error) {
    console.error('‚ùå API: Blank cap products error:', error);
    return NextResponse.json({
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      config: {
        projectId: process.env.NEXT_PUBLIC_SANITY_PROJECT_ID,
        dataset: process.env.NEXT_PUBLIC_SANITY_DATASET,
        apiToken: process.env.SANITY_API_TOKEN ? 'SET' : 'MISSING',
        environment: process.env.NODE_ENV
      }
    }, { status: 500 });
  }
}